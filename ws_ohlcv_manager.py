# file: ws_ohlcv_manager.py
from config import Config
import time
import math
import json
import threading
from queue import Queue, Empty
from collections import defaultdict
from dataclasses import dataclass
from typing import Dict, List, Optional

import websocket  # pip install websocket-client

# ---- –ù–ê–°–¢–†–û–ô–ö–ò ----
BINANCE_WS_URL = "wss://fstream.binance.com/ws"  # –§–¨–Æ–ß–ï–†–°–´!
TTL_SECONDS = Config.TTL_SECONDS          # –¥–µ—Ä–∂–∏–º –ø–æ—Ç–æ–∫ 30 —Å–µ–∫—É–Ω–¥ —Å –º–æ–º–µ–Ω—Ç–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ touch()
AGG_INTERVAL_SEC = Config.AGG_INTERVAL_SEC           # –æ–¥–∏–Ω –±–∞—Ä –≤ —Å–µ–∫—É–Ω–¥—É –ø–æ –õ–û–ö–ê–õ–¨–ù–û–ú–£ —Ç–∞–π–º–µ—Ä—É
QUEUE_MAXSIZE = 10000         # —Ä–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏ —Ç–∏–∫–æ–≤ –Ω–∞ —Å–∏–º–≤–æ–ª
#TICK_STREAM = "@aggTrade"
TICK_STREAM = "@trade"

def symbol_norm(sym: str) -> str:
    return sym.lower()

# ---------- HUB: –æ—á–µ—Ä–µ–¥–∏ —Ç–∏–∫–æ–≤ ----------
class StreamHub:
    def __init__(self, max_queue=QUEUE_MAXSIZE):
        self._q: Dict[str, Queue] = {}
        self._lock = threading.Lock()
        self._max_queue = max_queue

    def ensure_symbol(self, symbol: str):
        if symbol in self._q:
            return
        with self._lock:
            if symbol not in self._q:
                self._q[symbol] = Queue(maxsize=self._max_queue)

    def has_symbol(self, symbol: str) -> bool:
        return symbol in self._q

    def push(self, symbol: str, tick: dict):
        q = self._q.get(symbol)
        if q is None:
            self.ensure_symbol(symbol)
            q = self._q[symbol]
        try:
            q.put_nowait(tick)
        except Exception:
            # –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ ‚Äî –¥—Ä–æ–ø (–∏–ª–∏ –∑–∞–º–µ–Ω–∏ –Ω–∞ q.put() –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏)
            pass

    def drain_now(self) -> Dict[str, List[dict]]:
        """–ó–∞–±—Ä–∞—Ç—å –≤—Å—ë, —á—Ç–æ –µ—Å—Ç—å –≤ –æ—á–µ—Ä–µ–¥—è—Ö, –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –∏ –Ω–µ–±–ª–æ–∫–∏—Ä—É—é—â–µ."""
        out: Dict[str, List[dict]] = {}
        for sym, q in list(self._q.items()):
            acc = []
            while True:
                try:
                    acc.append(q.get_nowait())
                except Empty:
                    break
            if acc:
                out[sym] = acc
        return out

    def drop_symbol(self, symbol: str):
        with self._lock:
            self._q.pop(symbol, None)

# ---------- WS Reader ----------
class WsReader(threading.Thread):
    """–ß–∏—Ç–∞–µ—Ç <symbol>{TICK_STREAM} c Binance Futures –∏ –ø–∏—à–µ—Ç —Ç–∏–∫–∏ –≤ hub."""
    def __init__(self, symbol: str, hub: StreamHub):
        super().__init__(daemon=True, name=f"WS-{symbol}")
        self.symbol = symbol
        self.hub = hub
        self.stop_event = threading.Event()
        self.wsapp: Optional[websocket.WebSocketApp] = None

    def run(self):
        stream_name = f"{self.symbol}{TICK_STREAM}"
        url = f"{BINANCE_WS_URL}/{stream_name}"

        backoff = 1
        while not self.stop_event.is_set():
            try:
                self.wsapp = websocket.WebSocketApp(
                    url,
                    on_message=self._on_message,
                    on_error=self._on_error,
                    on_close=self._on_close,
                )

                def on_open(wsapp):
                    nonlocal backoff
                    backoff = 1
                self.wsapp.on_open = on_open

                # –ó–∞–ø—É—Å–∫; –≤—ã—Ö–æ–¥–∏–º, –µ—Å–ª–∏ stop() –∑–∞–∫—Ä—ã–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                self.wsapp.run_forever(ping_interval=15, ping_timeout=10)
            except Exception:
                pass

            if self.stop_event.is_set():
                break

            time.sleep(backoff)
            backoff = min(backoff * 2, 30)

    def _on_message(self, wsapp, message: str):
        try:
            msg = json.loads(message)
            # aggTrade: p=price, q=qty, T=tradeTime, E=eventTime
            tick = {
                "ts": int(msg.get("T") or msg.get("E")),  # —Å–æ—Ö—Ä–∞–Ω—è–µ–º –±–∏—Ä–∂–µ–≤–æ–π ts –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
                "price": float(msg["p"]),
                "qty": float(msg["q"]),
            }
            self.hub.push(self.symbol, tick)
        except Exception:
            pass

    def _on_error(self, wsapp, error):
        pass

    def _on_close(self, wsapp, status_code, msg):
        pass

    def stop(self):
        self.stop_event.set()
        try:
            if self.wsapp is not None:
                # –∂–µ—Å—Ç–∫–æ —Ä–≤–µ–º run_forever
                self.wsapp.keep_running = False
                self.wsapp.close()
        except Exception:
            pass

# ---------- –ê–≥—Ä–µ–≥–∞—Ç–æ—Ä: –±–∞—Ä –∏–∑ "–±–∞–∫–µ—Ç–∞" (–ø–æ—Ä—è–¥–æ–∫ = –ø–æ—Ä—è–¥–æ–∫ –ø—Ä–∏—Ö–æ–¥–∞) ----------
def ohlcv_bucket(ticks: List[dict], t_sec: int) -> Optional[dict]:
    if not ticks:
        return None
    prices = [t["price"] for t in ticks]        # –ø–æ—Ä—è–¥–æ–∫ ‚Äî –∫–∞–∫ –ø—Ä–∏—à–ª–∏ –≤ –æ—á–µ—Ä–µ–¥—å
    qtys   = [t.get("qty", 0.0) for t in ticks]
    return {
        "t": t_sec,              # –º–µ—Ç–∫–∞ –±–∞—Ä–∞ = —Å–µ–∫—É–Ω–¥–∞ –∑–∞–∫—Ä—ã—Ç–∏—è (—Ü–µ–ª–∞—è)
        "o": prices[0],
        "h": max(prices),
        "l": min(prices),
        "c": prices[-1],
        "v": sum(qtys),
        "n": len(ticks),
    }

# ---------- –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–∏–º–≤–æ–ª–æ–≤ –∏ TTL ----------
@dataclass
class SymState:
    reader: WsReader
    expires_at: float  # epoch seconds

class StreamManager:
    """
    –†–ï–ñ–ï–ú –ü–û –õ–û–ö–ê–õ–¨–ù–û–ú–£ –¢–ê–ô–ú–ï–†–£:
      - —Å—Ç–∞—Ä—Ç —Å –±–ª–∏–∂–∞–π—à–µ–π —Ü–µ–ª–æ–π —Å–µ–∫—É–Ω–¥—ã (ceil(now)),
      - –Ω–∞ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ —Å–ø–∏–º –¥–æ —Ä–æ–≤–Ω–æ–π –≥—Ä–∞–Ω–∏—Ü—ã '‚Ä¶:01.000', '‚Ä¶:02.000', ‚Ä¶
      - –æ–¥–∏–Ω –±–∞—Ä –Ω–∞ —Å–µ–∫—É–Ω–¥—É, –±–µ–∑ –¥—É–±–ª–µ–π.
    """
    def __init__(self):
        self.hub = StreamHub()
        self._states: Dict[str, SymState] = {}
        self._lock = threading.Lock()
        self._stop = threading.Event()

        self._th_agg = threading.Thread(target=self._aggregator_loop,
                                        daemon=True, name="Aggregator")
        self._th_gc  = threading.Thread(target=self._gc_loop,
                                        daemon=True, name="GC")

        # —Ç–µ–∫—É—â–∏–π "–±–∞–∫–µ—Ç" –¥–ª—è –Ω–∞–∫–∞–ø–ª–∏–≤–∞–Ω–∏—è —Ç–∏–∫–æ–≤ –º–µ–∂–¥—É —Ä–∞—Å–ø–µ—á–∞—Ç–∫–∞–º–∏: symbol -> [ticks]
        self._bucket: Dict[str, List[dict]] = defaultdict(list)

    def start(self):
        self._th_agg.start()
        self._th_gc.start()

    def stop(self):
        self._stop.set()
        with self._lock:
            for st in self._states.values():
                st.reader.stop()
        self._th_agg.join(timeout=1)
        self._th_gc.join(timeout=1)

    def touch(self, symbol: str):
        symbol = symbol_norm(symbol)
        with self._lock:
            if symbol not in self._states:
                print(f"üöÄ Starting stream for {symbol.upper()}")
                self.hub.ensure_symbol(symbol)
                reader = WsReader(symbol, self.hub)
                self._states[symbol] = SymState(
                    reader=reader,
                    expires_at=time.time() + TTL_SECONDS
                )
                reader.start()
            else:
                self._states[symbol].expires_at = time.time() + TTL_SECONDS

    # --- –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ ---
    def _sleep_to_wall_second(self, target_sec: int):
        """–ü–æ—Å–ø–∞—Ç—å –¥–æ —Ä–æ–≤–Ω–æ–π —Å—Ç–µ–Ω–æ—á–Ω–æ–π —Å–µ–∫—É–Ω–¥—ã target_sec (UTC)."""
        delay = target_sec - time.time()
        if delay > 0:
            time.sleep(delay)

    def _aggregator_loop(self):
        step = AGG_INTERVAL_SEC

        # —Ü–µ–ª–∏–º—Å—è —Ä–æ–≤–Ω–æ –≤ –±–ª–∏–∂–∞–π—à—É—é —Ü–µ–ª—É—é —Å–µ–∫—É–Ω–¥—É (ceil(now))
        next_sec_label = int(math.ceil(time.time()))

        while not self._stop.is_set():
            # 1) –∂–¥—ë–º –†–û–í–ù–û–≠ —Å–µ–∫—É–Ω–¥—É –Ω–∞ ¬´—Å—Ç–µ–Ω–µ –≤—Ä–µ–º–µ–Ω–∏¬ª
            self._sleep_to_wall_second(next_sec_label)

            # 2) –∑–∞–±–∏—Ä–∞–µ–º –Ω–∞–∫–æ–ø–∏–≤—à–∏–µ—Å—è —Ç–∏–∫–∏ –∫ —ç—Ç–æ–º—É –º–æ–º–µ–Ω—Ç—É –≤ —Ç–µ–∫—É—â–∏–π –±–∞–∫–µ—Ç
            batch = self.hub.drain_now()
            for sym, ticks in batch.items():
                self._bucket[sym].extend(ticks)

            # 3) —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ–∫—É–Ω–¥—É (–º–µ—Ç–∫–∞ = next_sec_label), –ø–µ—á–∞—Ç—å –∏ –æ—á–∏—Å—Ç–∫–∞ –±–∞–∫–µ—Ç–∞
            rows = []
            for sym, ticks in list(self._bucket.items()):
                if not ticks:
                    continue
                bar = ohlcv_bucket(ticks, t_sec=next_sec_label)
                if bar:
                    rows.append((bar["t"], sym.upper(), bar))
                self._bucket[sym].clear()

            for _, sym, bar in sorted(rows, key=lambda r: (r[0], r[1])):
                print(f"{sym} {time.strftime('%H:%M:%S', time.localtime(bar['t']))} "
                      f"O:{bar['o']} H:{bar['h']} L:{bar['l']} C:{bar['c']} V:{bar['v']} N:{bar['n']}")

            # 4) —Å–ª–µ–¥—É—é—â–∞—è —Ä–æ–≤–Ω–∞—è —Å–µ–∫—É–Ω–¥–∞
            now = time.time()
            next_sec_label = int(now) + 1

    def _gc_loop(self):
        while not self._stop.is_set():
            time.sleep(1)  # –ø—Ä–æ–≤–µ—Ä—è–µ–º TTL –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
            now = time.time()
            expired: List[str] = []
            with self._lock:
                for sym, st in list(self._states.items()):
                    if now >= st.expires_at:
                        st.reader.stop()
                        expired.append(sym)
                        self.hub.drop_symbol(sym)
                        del self._states[sym]
                        # –ø–æ–¥—á–∏—Å—Ç–∏–º —Ç–µ–∫—É—â–∏–π –±–∞–∫–µ—Ç
                        self._bucket.pop(sym, None)
            for sym in expired:
                print(f"‚èπÔ∏è Stopped {sym.upper()} (TTL expired)")


# ---------- –ü—Ä–∏–º–µ—Ä ----------
if __name__ == "__main__":
    mgr = StreamManager()
    mgr.start()

    # –∏–º–∏—Ç–∏—Ä—É–µ–º ¬´—É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∏–∑ –¢–ì¬ª
    mgr.touch("btcusdt")
    mgr.touch("ethusdt")

    # —á–µ—Ä–µ–∑ 15—Å –æ–±–Ω–æ–≤–∏–º BTC (–ø—Ä–æ–¥–ª–µ–≤–∞–µ–º –µ—â—ë –Ω–∞ 10 –º–∏–Ω—É—Ç)
    def refresher():
        time.sleep(4)
        print("[TG] refresh BTC")
        mgr.touch("btcusdt")

    # —á–µ—Ä–µ–∑ 10—Å –¥–æ–±–∞–≤–∏–º BNB
    def add_bnb():
        time.sleep(7)
        print("[TG] BNB notification")
        mgr.touch("bnbusdt")

    threading.Thread(target=refresher, daemon=True).start()
    threading.Thread(target=add_bnb, daemon=True).start()

    try:
        while True:
            time.sleep(0.5)
    except KeyboardInterrupt:
        mgr.stop()
